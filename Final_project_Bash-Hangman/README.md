TO BE DELETED (START)

Create a README.md text file (named exactly that!) in your ~/project folder that explains your project. This file should include your Project title, the URL of your video (created in step 1 above) and a description of your project. You may use the below as a template.

TO BE DELETED (END)

# BASH HANGMAN
## Video Demo:  <https://www.youtube.com/watch?v=WUjuXTiBsag>
## Description:
The Bash Hangman was created in order to graduate from Harvard's CS50P course. Bash Hangman (further reffered as "the game") is a simple terminal based game inspired by the famous real world game hangman. The game is designed around main() function containing several other functions, list of the nouns in English (nounlist.csv) in CSV format and JSON file with dictionary (dictionary.json). Player can interact with the game using keyboard only. The game lets player chose the difficulty (i.e. number of lives), complexity of the word (length) and prints out the brackets indicating the number and positions of the letters in the word to guess. The word itself is hidden to the player and is chosen randomly from the generated list, according to the given length. Player is then prompted in a loop to guess a letter which the word may content until he/she manages to guess all the letters or exhaust all of his/her lives. If player chooses to, he/she can display the definition of the word in case he/she is not familiar with it. There is also in-build timer running, which is used to calculate the score.

## Libraries:
There is no 3rd party library used in the game. In-build libraries include:

**json:** to read the dictionary

**sys:** to exit the application

**random:** to chose random word from a list of words

**time:** to measure time from the first prompt to guess letter until victory

## Functions:
**main():** Function calls get_name(), chose_diff(), chose_len() and starts the timer. It creates empty list used_letters and guessed_letters and starts the while loop, which is going on until the life_count equals zero. In scenario when players exhausts all of his/her life, main() calls defeat() function and gets player to "end menu" by calling final_menu(). During the main game loop, player is being prompted for input in form of single letter. Depending on the input, player is rewarded in case of successful guess, punished by removing one of his lives in case of failure, warned about using the same letter multiple times or warned about invalid input. In case of victory, main() stops the time counter and calls victory() function, count_score() function and returns player to "end menu" by calling final_menu() as well.

**menu():** Function gives the player choice to start a game or quit the application.

**chose_diff():** Function enables player to chose difficulty (i.e. number of lives) for the game and returns integer based on predefined constants.

**chose_len():** Function enables player to chose the complexity (length) of the word to be guessed. Based on player input, the function returns tuple according to the predefined constants.

**pick_word(length):** Function takes length variable (tuple generated by chose_len() function) as an argument. It creates empty list and fills it with the words based on chosen length from CSV file nounlist.csv. Then the_word (to be guessed) is randomly picked from that list and returned by the function.

**print_status(used_letters, guessed_letters, lifes_left, the_word):** Helper function enables the application to interact with player. It takes several variables as arguments and prints them out in form of colorful text and emojis.
**victory(start, end, the_word):** Function takes time variables start and end as well as the_word as argument. It counts and prints total play time and congratulates player.

**defeat(the_word):** Defeat informs about loss and disclose the_word to the player.

**get_definition(the_word):** Function opens up the dictionary in JSON format and looks for the definition of the word. Player can chose to use this function in case he/she is not familiar with the word. If there is not such a word in the file dictionary.json, function prompts player to search for the word on-line. If there are several definitions and quotes for dictionary key (the_word), only the 1st one is printed out.

**final_menu(the_word):** Functions brings player to "final menu" and prompts to chose either to continue with another game, get the definition of the_word or quit the entire app.

**count_score(start, end, lifes_left, word_length, difficulty):** Function takes several variables as arguments and returns score in form of rounded float (basically int).

## Classes:
There is one class instance called TextColor, which is used to simplify coloring of the terminal text. This game could be as well based around OOP approach, but I decided to go with functions.

## Design choices, known bugs, possible further development:
I could certainly use the API approach either for generating random words or on getting the definitions. Problem with API is the disclosure of the key. It made me explore the technology behind this issue and there are certainly many solutions.

Printing colorful text in the Bash terminal is rather simple, however the approach I chose (ANSI syntax) does not work on Windows. Luckily there are 3rd party libraries to deal with this issue.

Function main() could be further worked on at partitioned into several other loops and functions, but I wanted to keep the "main game loop" visible and obvious.

The score and difficulty can be changed in order to achieve more challenging games. Also, it would be great to introduce I/O mechanism to keep track of the high score or give the player the opportunity to run several games in a row and sum up the scores from individual games (or lose every score in case of defeat after the series of victories).

I am also aware of exceeding the per-line length of the code, but I was not able to print hashes "#" in a manner without the conflict with printing design.

## Unit Test:
I found designing unit test for Bash Hangman rather challenging. Since I designed functions in "printing" rather then returning manner (which is not good as I found out) and user input was given within the function instead of passing it as an argument. This required me to simulate user input via StringIO module and "monkeypatching". Since chose_diff and chose_len functions use while loop until proper input is given and do not break, I did not find the way to test other inputs, then correct ones. I found some solutions on-line, but nothing satisfactory though.

## Credits:
The original nounlist is freely available on https://www.desiquintans.com/nounlist, credits goes to the author of this splendid list.

The JSON dictionary used for definitions of the words comes from Matthew Reagan https://github.com/matthewreagan/WebstersEnglishDictionary, credit goes to Matthew Reagan, who created JSON file out of Webster's English Dictionary.
